# -*- coding: utf-8 -*-
"""modelado probas TAMAR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Eij74C3kgTv_VDbHNd4pXouiAOLpjR6d
"""

import pandas as pd
import requests
from datetime import timedelta, datetime
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def getDataV3(variableID):
    url = f"https://api.bcra.gob.ar/estadisticas/v3.0/Monetarias/{variableID}"
    r = requests.get(url, verify=False)
    return pd.DataFrame(r.json().get('results')).set_index('fecha')

events = {
    'TTM26': datetime(2026, 3, 16),
    'TTJ26': datetime(2026, 6, 30),
    'TTS26': datetime(2026, 9, 15),
    'TTD26': datetime(2026, 12, 15)
}

"""# Modelado PDF TAMAR a dic26"""

tamar_tea = getDataV3(variableID=45)['valor'] / 100   # ID=45 es la TAMAR
tamar_tea.index = pd.to_datetime(tamar_tea.index)
tamar_tea = tamar_tea.sort_index()
tamar_tea = tamar_tea.loc[tamar_tea.index > '2025-01-15']
tamar_tem_spot = ((1 + tamar_tea)**(1/12) - 1)
tamar_tem = tamar_tem_spot.to_frame(name='tamar_tem_spot')

"""Sea $ X \sim \text{Lognormal}(\mu, \sigma^2) $, con:

$$
X = \exp(Y), \quad \text{donde } Y \sim N(\mu, \sigma^2)
$$

Queremos encontrar parámetros $ \mu $ y $ \sigma $ tales que se cumplan las siguientes condiciones:

1. **Media deseada**: Media REM a dic 26
   $$
   \mathbb{E}[X] = e^{\mu + \frac{1}{2}\sigma^2} = 0.0143
   $$

2. **Probabilidad de cola superior**:  
outlier_prob caso max REM 1/41 (prob: 2.44%  value: 2.71% tem)

   $$
   \mathbb{P}(X > 0.0271) \geq 0.0244
   $$

3. **Dominio efectivo**:
min: riesgo pais 200 bps + FR 400 bps
   
   $$
   X \geq 0.0049
   $$

El problema se formula como una minimización penalizada:

$$
\min_{\mu,\ \sigma > 0} \left( \left( e^{\mu + \frac{1}{2}\sigma^2} - 0.0143 \right)^2 + \lambda \cdot \max\left(0,\ 0.0244 - \mathbb{P}(X > 0.0271) \right)^2 \right)
$$

donde  $\lambda$  pondera la penalización por no cumplir la probabilidad deseada en la cola.

"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import lognorm
from scipy.optimize import minimize

target_mean = 0.0143 # media REM a dic 26
target_prob = 0.0244 # outlier_prob caso max REM 1/41
threshold = 0.0271 # outlier_value REM max a dic26
min_val = 0.0049 # min: riesgo pais 200 bps + FR 400 bps

def loss(params):
    mu, sigma = params
    dist = lognorm(s=sigma, scale=np.exp(mu))
    mean = dist.mean()
    prob = 1 - dist.cdf(threshold)
    penal_mean = (mean - target_mean)**2
    penal_prob = max(0, target_prob - prob)**2
    return penal_mean + 10 * penal_prob

res = minimize(loss, x0=[np.log(target_mean), 0.5], bounds=[(None, None), (1e-3, 2)])

mu_opt, sigma_opt = res.x
dist = lognorm(s=sigma_opt, scale=np.exp(mu_opt))

x = np.linspace(min_val, 0.07, 1000)
pdf = dist.pdf(x)
pdf[x < min_val] = 0

plt.plot(x, pdf)
plt.title('PDF tasa TAMAR')
plt.xlabel('Tasa')
plt.ylabel('Densidad')
plt.grid(True)


print(f"Params de la lognormal: mu: {mu_opt:.4f}, sigma: {sigma_opt:.4f}")
plt.show()


# setear N como cantidad de escenarios discretos a modelar, MAX como maximo valor posible de TAMAR a dic26 escenario caos total
N, MAX = 15, 0.055
edges = np.linspace(min_val, MAX, N + 1)
centers = 0.5 * (edges[:-1] + edges[1:])
probs = dist.cdf(edges[1:]) - dist.cdf(edges[:-1])

df = pd.DataFrame({'TAMAR_DIC_26_pct': centers, 'proba_pct': probs}).mul(100).round(1)
display(df)

# probas de cada tamar a dic26
df.set_index('TAMAR_DIC_26_pct')['proba_pct'].plot(kind='bar')

TAMAR_MEANS = []
for TAMAR_TARGET in df.TAMAR_DIC_26_pct.tolist():
    tamar_tem1 = tamar_tem.copy()
    tamar_tem1.index=pd.to_datetime(tamar_tem1.index)
    last=tamar_tem1.index.max()
    lv=tamar_tem1.loc[last,'tamar_tem_spot']
    nd=pd.bdate_range(last+pd.Timedelta(1,'D'),'2026-12-15')
    vals=[lv+(TAMAR_TARGET/100-lv)*i/len(nd) for i in range(1,len(nd)+1)]
    tamar_tem2=pd.DataFrame({'tamar_tem_spot':vals},index=nd)
    tamar_tem1=pd.concat([tamar_tem1,tamar_tem2]).sort_index()
    TAMAR_MEANS.append(tamar_tem1.mean().iloc[0]*100)

df['TAMAR_MEAN'] = TAMAR_MEANS

fixed_rate = 2.14
months = 22.53

df['fixed_amort_b100'] = 100 * (1+fixed_rate/100)**months
df['tamar_amort_b100'] = 100 * (1+df['TAMAR_MEAN']/100)**months
df['tamar_diff_b100'] = np.where(df['fixed_amort_b100'] > df['tamar_amort_b100'], 0, df['tamar_amort_b100']-df['fixed_amort_b100'])
df

call_value_b100 = df['proba_pct'].divide(100) @ df['tamar_diff_b100']
call_value_b100

